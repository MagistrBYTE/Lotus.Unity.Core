//=====================================================================================================================
// Проект: LotusPlatform
// Раздел: Модуль базового ядра
// Подраздел: Подсистема коллекций
// Автор: MagistrBYTE aka DanielDem <dementevds@gmail.com>
//---------------------------------------------------------------------------------------------------------------------
/** \file LotusCollectionDequeArray.cs
*		Двусторонняя очередь на основе массива.
*/
//---------------------------------------------------------------------------------------------------------------------
// Версия: 1.0.0.0
// Последнее изменение от 27.03.2022
//=====================================================================================================================
using System;
using System.Collections;
using System.Collections.Generic;
//=====================================================================================================================
namespace Lotus
{
	namespace Core
	{
		//-------------------------------------------------------------------------------------------------------------
		//! \addtogroup CoreCollections
		/*@{*/
		//-------------------------------------------------------------------------------------------------------------
		/// <summary>
		/// Двусторонняя очередь на основе массива
		/// </summary>
		/// <remarks>
		/// Реализация двусторонней очереди на основе массива, с полной поддержкой функциональности <see cref="ListArray{TItem}"/>
		/// с учетом особенности реализации двусторонней очереди
		/// </remarks>
		/// <typeparam name="TItem">Тип элемента очереди</typeparam>
		//-------------------------------------------------------------------------------------------------------------
		[Serializable]
		public class DequeArray<TItem> : ListArray<TItem>
		{
			#region ======================================= ДАННЫЕ ====================================================
			// Основные параметры
			protected Int32 mStartOffset;
			#endregion

			#region ======================================= СВОЙСТВА ==================================================
			//
			// ОСНОВНЫЕ ПАРАМЕТРЫ
			//
			/// <summary>
			/// Начальное смещение для формирование очереди
			/// </summary>
			public Int32 StartOffset
			{
				get { return mStartOffset; }
			}
			#endregion

			#region ======================================= КОНСТРУКТОРЫ ==============================================
			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Конструктор инициализирует данные двусторонней очереди предустановленными данными
			/// </summary>
			//---------------------------------------------------------------------------------------------------------
			public DequeArray()
				: base(INIT_MAX_COUNT)
			{
				mStartOffset = INIT_MAX_COUNT / 2;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Конструктор инициализирует данные двусторонней очереди указанными данными
			/// </summary>
			/// <param name="max_count">Максимальное количество элементов</param>
			//---------------------------------------------------------------------------------------------------------
			public DequeArray(Int32 max_count)
				: base(max_count)
			{
				mStartOffset = max_count / 2;
			}
			#endregion

			#region ======================================= ИНДЕКСАТОР ================================================
			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Индексация элементов очереди
			/// </summary>
			/// <param name="index">Индекс элемента</param>
			/// <returns>Элемент очереди</returns>
			//---------------------------------------------------------------------------------------------------------
			new public TItem this[Int32 index]
			{
				get { return mArrayOfItems[(mStartOffset + index) % mMaxCount]; }
				set
				{
					mArrayOfItems[(mStartOffset + index) % mMaxCount] = value;
				}
			}
			#endregion

			#region ======================================= ОБЩИЕ МЕТОДЫ ==============================================
			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Получение элемента очереди по индексу
			/// </summary>
			/// <param name="index">Индекс элемента очереди</param>
			/// <returns>Элемент очереди</returns>
			//---------------------------------------------------------------------------------------------------------
			public TItem GetElement(Int32 index)
			{
				return mArrayOfItems[(mStartOffset + index) % mMaxCount];
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Добавление элемента в начало очереди
			/// </summary>
			/// <param name="item">Элемент</param>
			//---------------------------------------------------------------------------------------------------------
			public void AddFront(TItem item)
			{
				// Если текущие количество элементов равно максимально возможному
				if (mCount == mMaxCount)
				{
					mMaxCount = mMaxCount * 2;
					TItem[] items = new TItem[mMaxCount];
					Array.Copy(mArrayOfItems, items, mCount);
					mArrayOfItems = items;
				}

				// Нет возможности добавить в начало очереди
				if (mStartOffset == 0)
				{
					mMaxCount = mMaxCount * 2;
					TItem[] items = new TItem[mMaxCount];
					mStartOffset = mMaxCount / 2;
					Array.Copy(mArrayOfItems, 0, items, mStartOffset, mCount);
					mArrayOfItems = items;
				}

				// Уменьшаем индекс начало очереди
				mStartOffset--;
				mArrayOfItems[mStartOffset] = item;
				mCount++;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Добавление элемента в конец очереди
			/// </summary>
			/// <param name="item">Элемент</param>
			//---------------------------------------------------------------------------------------------------------
			public void AddBack(TItem item)
			{
				// Если текущие количество элементов равно максимально возможному
				if (mCount == mMaxCount)
				{
					mMaxCount = mMaxCount * 2;
					TItem[] items = new TItem[mMaxCount];
					Array.Copy(mArrayOfItems, items, mCount);
					mArrayOfItems = items;
				}

				mArrayOfItems[mStartOffset + mCount] = item;
				mCount++;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Взятие и удаление элемента из начала очереди
			/// </summary>
			/// <returns>Элемент</returns>
			//---------------------------------------------------------------------------------------------------------
			public TItem RemoveFront()
			{
				if (mCount > 0)
				{
					TItem item = mArrayOfItems[mStartOffset];
					mArrayOfItems[mStartOffset] = default(TItem);
					mStartOffset++;
					mCount--;
					return item;
				}
				else
				{
#if (UNITY_2017_1_OR_NEWER)
					UnityEngine.Debug.LogError("Not element in deque!!!");
#else
					XLogger.LogError("Not element in deque!!!");
#endif
					return default(TItem);
				}
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Взятие и удаление элемента из конца очереди
			/// </summary>
			/// <returns>Элемент</returns>
			//---------------------------------------------------------------------------------------------------------
			public TItem RemoveBack()
			{
				if (mCount > 0)
				{
					mCount--;
					TItem item = mArrayOfItems[mCount];
					mArrayOfItems[mCount] = default(TItem);

					return item;
				}
				else
				{
#if (UNITY_2017_1_OR_NEWER)
					UnityEngine.Debug.LogError("Not element in deque!!!");
#else
					XLogger.LogError("Not element in deque!!!");
#endif
					return default(TItem);
				}
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Взятие элемента начала очереди (без его удаления)
			/// </summary>
			/// <returns>Элемент</returns>
			//---------------------------------------------------------------------------------------------------------
			public TItem PeekFront()
			{
				if (mCount > 0)
				{
					return mArrayOfItems[mStartOffset];
				}
				else
				{
#if (UNITY_2017_1_OR_NEWER)
					UnityEngine.Debug.LogError("Not element in deque!!!");
#else
					XLogger.LogError("Not element in deque!!!");
#endif
					return default(TItem);
				}

			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Взятие элемента конца очереди (без его удаления)
			/// </summary>
			/// <returns>Элемент</returns>
			//---------------------------------------------------------------------------------------------------------
			public TItem PeekBack()
			{
				if (mCount > 0)
				{
					return mArrayOfItems[mCount - 1];
				}
				else
				{
#if (UNITY_2017_1_OR_NEWER)
					UnityEngine.Debug.LogError("Not element in deque!!!");
#else
					XLogger.LogError("Not element in deque!!!");
#endif
					return default(TItem);
				}

			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Проверка на наличие элемента в очереди
			/// </summary>
			/// <param name="item">Элемент</param>
			/// <returns>Статус наличия</returns>
			//---------------------------------------------------------------------------------------------------------
			public new Boolean Contains(TItem item)
			{
				Int32 index = mStartOffset;
				Int32 count = mCount;

				while (count-- > 0)
				{
					if (mArrayOfItems[index].Equals(item))
					{
						return true;
					}
					index = (index + 1) % mMaxCount;
				}

				return false;
			}

			//---------------------------------------------------------------------------------------------------------
			/// <summary>
			/// Очистка очереди
			/// </summary>
			//---------------------------------------------------------------------------------------------------------
			public new void Clear()
			{
				Array.Clear(mArrayOfItems, mStartOffset, mCount);
				mStartOffset = mMaxCount / 2;
				mCount = 0;
			}
			#endregion
		}
		//-------------------------------------------------------------------------------------------------------------
		/*@}*/
		//-------------------------------------------------------------------------------------------------------------
	}
}
//=====================================================================================================================